#!/bin/bash
# Template generator for DROO's dotfiles
# This script generates project templates for various types

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    local status=$1
    local message=$2
    case $status in
        "OK")
            echo -e "${GREEN}✓${NC} $message"
            ;;
        "WARN")
            echo -e "${YELLOW}⚠${NC} $message"
            ;;
        "ERROR")
            echo -e "${RED}✗${NC} $message"
            ;;
        "INFO")
            echo -e "${BLUE}ℹ${NC} $message"
            ;;
    esac
}

# Function to show usage
show_usage() {
    echo "Usage: $0 <template-type> <project-name> [options]"
    echo ""
    echo "Available templates:"
    echo "  web3          - Ethereum/Solana smart contract project"
    echo "  nextjs        - Next.js with TypeScript and Tailwind"
    echo "  react         - React with TypeScript and Vite"
    echo "  rust          - Rust project with common dependencies"
    echo "  elixir        - Elixir Phoenix project"
    echo "  node          - Node.js project with TypeScript"
    echo "  python        - Python project with virtual environment"
    echo "  go            - Go project with modules"
    echo ""
    echo "Options:"
    echo "  --web3-type <type>    - For web3: ethereum, solana, or both (default: ethereum)"
    echo "  --with-tests          - Include comprehensive test setup"
    echo "  --with-docs           - Include documentation setup"
    echo "  --with-ci             - Include CI/CD configuration"
    echo "  --with-direnv         - Include direnv environment setup"
    echo "  --with-devenv         - Include devenv environment setup"
    echo ""
    echo "Examples:"
    echo "  $0 web3 my-defi-project"
    echo "  $0 nextjs my-webapp --with-tests --with-ci"
    echo "  $0 rust my-cli-tool --with-docs"
    echo "  $0 web3 my-project --with-direnv --with-devenv"
}

# Function to create web3 project
create_web3_project() {
    local name="$1"
    local web3_type="${2:-ethereum}"
    local with_direnv="$3"
    local with_devenv="$4"

    print_status "INFO" "Creating web3 project: $name ($web3_type)"

    mkdir -p "$name"
    cd "$name"

    # Initialize git
    git init

    # Create basic structure
    mkdir -p src contracts scripts test docs

    # Create README
    cat > README.md << EOF
# $name

Web3 project generated by DROO's dotfiles template.

## Features

- Smart contract development
- Testing framework
- Deployment scripts
- Documentation

## Setup

```bash
# Install dependencies
npm install

# For Ethereum development
forge install
forge build
forge test

# For Solana development
anchor build
anchor test
```

## Development

```bash
# Start local development
npm run dev

# Run tests
npm test

# Deploy contracts
npm run deploy
```

## License

MIT
EOF

    # Create package.json
    cat > package.json << EOF
{
  "name": "$name",
  "version": "0.1.0",
  "description": "Web3 project generated by DROO's dotfiles",
  "main": "index.js",
  "scripts": {
    "dev": "echo 'Start development server'",
    "build": "echo 'Build project'",
    "test": "echo 'Run tests'",
    "deploy": "echo 'Deploy contracts'",
    "lint": "echo 'Run linter'",
    "format": "echo 'Format code'"
  },
  "keywords": ["web3", "blockchain", "ethereum", "solana"],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0",
    "prettier": "^3.0.0",
    "eslint": "^8.0.0"
  }
}
EOF

    # Ethereum-specific setup
    if [[ "$web3_type" == "ethereum" || "$web3_type" == "both" ]]; then
        print_status "INFO" "Setting up Ethereum development environment..."

        # Initialize Foundry
        forge init --no-commit

        # Create foundry.toml
        cat > foundry.toml << EOF
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc_version = "0.8.19"
optimizer = true
optimizer_runs = 200

[profile.default.fuzz]
runs = 1000

[profile.default.invariant]
runs = 1000
depth = 15
fail_on_revert = false
EOF

        # Create sample contract
        cat > src/Counter.sol << EOF
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract Counter {
    uint256 public count;

    event CountIncremented(uint256 newCount);

    function increment() public {
        count++;
        emit CountIncremented(count);
    }

    function decrement() public {
        require(count > 0, "Counter: cannot decrement below zero");
        count--;
        emit CountIncremented(count);
    }
}
EOF

        # Create test
        cat > test/Counter.t.sol << EOF
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;

    function setUp() public {
        counter = new Counter();
    }

    function testIncrement() public {
        counter.increment();
        assertEq(counter.count(), 1);
    }

    function testDecrement() public {
        counter.increment();
        counter.increment();
        counter.decrement();
        assertEq(counter.count(), 1);
    }
}
EOF
    fi

    # Solana-specific setup
    if [[ "$web3_type" == "solana" || "$web3_type" == "both" ]]; then
        print_status "INFO" "Setting up Solana development environment..."

        # Create Anchor.toml
        cat > Anchor.toml << EOF
[features]
seeds = false
skip-lint = false

[programs.localnet]
$name = "$name"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
EOF

        # Create Cargo.toml
        cat > Cargo.toml << EOF
[package]
name = "$name"
version = "0.1.0"
description = "Generated Solana program"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "$name"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []

[dependencies]
anchor-lang = "0.28.0"
EOF

        # Create program
        mkdir -p programs/"$name"/src
        cat > programs/"$name"/src/lib.rs << EOF
use anchor_lang::prelude::*;

declare_id!("$name");

#[program]
pub mod $name {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}
EOF
    fi

    # Create .gitignore
    cat > .gitignore << EOF
# Dependencies
node_modules/
target/
dist/

# Environment
.env
.env.local
.env.production

# Build outputs
out/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
EOF

    print_status "OK" "Web3 project '$name' created successfully!"
}

# Function to create Next.js project
create_nextjs_project() {
    local name="$1"
    local with_tests="$2"
    local with_ci="$3"
    local with_direnv="$4"
    local with_devenv="$5"

    print_status "INFO" "Creating Next.js project: $name"

    # Use create-next-app
    npx create-next-app@latest "$name" --typescript --tailwind --eslint --app --src-dir --import-alias "@/*" --yes

    cd "$name"

    # Add additional dependencies
    npm install @types/node @types/react @types/react-dom

    if [[ "$with_tests" == "true" ]]; then
        print_status "INFO" "Adding test setup..."
        npm install --save-dev jest @testing-library/react @testing-library/jest-dom jest-environment-jsdom
        npm install --save-dev @types/jest

        # Create jest.config.js
        cat > jest.config.js << EOF
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  dir: './',
})

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
}

module.exports = createJestConfig(customJestConfig)
EOF

        # Create jest.setup.js
        cat > jest.setup.js << EOF
import '@testing-library/jest-dom'
EOF

        # Update package.json scripts
        npm pkg set scripts.test="jest"
        npm pkg set scripts.test:watch="jest --watch"
    fi

    if [[ "$with_ci" == "true" ]]; then
        print_status "INFO" "Adding CI/CD setup..."
        mkdir -p .github/workflows

        cat > .github/workflows/ci.yml << EOF
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Use Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm test

    - name: Build
      run: npm run build
EOF
    fi

    print_status "OK" "Next.js project '$name' created successfully!"
}

# Function to create Rust project
create_rust_project() {
    local name="$1"
    local with_docs="$2"
    local with_direnv="$3"
    local with_devenv="$4"

    print_status "INFO" "Creating Rust project: $name"

    cargo new "$name"
    cd "$name"

    # Update Cargo.toml with common dependencies
    cat > Cargo.toml << EOF
[package]
name = "$name"
version = "0.1.0"
edition = "2021"
authors = ["DROO <drew@axol.io>"]
description = "Generated Rust project"
license = "MIT"
repository = ""

[dependencies]
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
thiserror = "1.0"
clap = { version = "4.0", features = ["derive"] }
tracing = "0.1"
tracing-subscriber = "0.3"

[dev-dependencies]
tokio-test = "0.4"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"
EOF

    if [[ "$with_docs" == "true" ]]; then
        print_status "INFO" "Adding documentation setup..."

        # Create docs directory
        mkdir -p docs

        cat > docs/README.md << EOF
# $name Documentation

## Overview

This is the documentation for the $name project.

## Building

```bash
cargo doc --open
```

## API Reference

The API documentation is generated from the source code comments.
EOF

        # Update Cargo.toml to include documentation
        {
            echo ""
            echo "[package.metadata.docs.rs]"
            echo "rustdoc-args = [\"--cfg\", \"docsrs\"]"
        } >> Cargo.toml
    fi

    print_status "OK" "Rust project '$name' created successfully!"
}

# Function to create Elixir project
create_elixir_project() {
    local name="$1"
    local with_direnv="$2"
    local with_devenv="$3"

    print_status "INFO" "Creating Elixir project: $name"

    # Use mix to create new project
    mix phx.new "$name" --no-ecto --no-mailer --no-dashboard --no-install

    cd "$name"

    # Update mix.exs with additional dependencies
    cat > mix.exs << EOF
defmodule ${name^}.MixProject do
  use Mix.Project

  def project do
    [
      app: :${name},
      version: "0.1.0",
      elixir: "~> 1.14",
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps()
    ]
  end

  def application do
    [
      mod: {${name^}.Application, []},
      extra_applications: [:logger, :runtime_tools]
    ]
  end

  defp deps do
    [
      {:phoenix, "~> 1.7.0"},
      {:phoenix_html, "~> 3.0"},
      {:phoenix_live_reload, "~> 1.2", only: :dev},
      {:phoenix_live_view, "~> 0.19.0"},
      {:floki, ">= 0.30.0", only: :test},
      {:phoenix_live_dashboard, "~> 0.8.0"},
      {:esbuild, "~> 0.7", runtime: Mix.env() == :dev},
      {:tailwind, "~> 0.2.0", runtime: Mix.env() == :dev},
      {:swoosh, "~> 1.3"},
      {:finch, "~> 0.13"},
      {:telemetry_metrics, "~> 0.6"},
      {:telemetry_poller, "~> 1.0"},
      {:gettext, "~> 0.20"},
      {:jason, "~> 1.2"},
      {:dns_cluster, "~> 0.1.1"},
      {:bandit, "~> 1.0"}
    ]
  end

  defp aliases do
    [
      setup: ["deps.get", "assets.setup", "assets.build"]
    ]
  end
end
EOF

    print_status "OK" "Elixir project '$name' created successfully!"
}

# Main function
main() {
    local template_type="$1"
    local project_name="$2"
    local web3_type="ethereum"
    local with_tests="false"
    local with_docs="false"
    local with_ci="false"
    local with_direnv="true"
    local with_devenv="false"

    # Parse additional arguments
    shift 2
    while [[ $# -gt 0 ]]; do
        case $1 in
            --web3-type)
                web3_type="$2"
                shift 2
                ;;
            --with-tests)
                with_tests="true"
                shift
                ;;
            --with-docs)
                with_docs="true"
                shift
                ;;
            --with-ci)
                with_ci="true"
                shift
                ;;
            --with-direnv)
                with_direnv="true"
                shift
                ;;
            --with-devenv)
                with_devenv="true"
                shift
                ;;
            *)
                echo "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Validate arguments
    if [[ -z "$template_type" || -z "$project_name" ]]; then
        show_usage
        exit 1
    fi

    # Check if project directory already exists
    if [[ -d "$project_name" ]]; then
        print_status "ERROR" "Project directory '$project_name' already exists"
        exit 1
    fi

    # Create project based on template type
    case "$template_type" in
        "web3")
            create_web3_project "$project_name" "$web3_type" "$with_direnv" "$with_devenv"
            ;;
        "nextjs")
            create_nextjs_project "$project_name" "$with_tests" "$with_ci" "$with_direnv" "$with_devenv"
            ;;
        "rust")
            create_rust_project "$project_name" "$with_docs" "$with_direnv" "$with_devenv"
            ;;
        "elixir")
            create_elixir_project "$project_name" "$with_direnv" "$with_devenv"
            ;;
        *)
            print_status "ERROR" "Unknown template type: $template_type"
            show_usage
            exit 1
            ;;
    esac

    print_status "OK" "Project '$project_name' created successfully!"
    echo ""
    echo "Next steps:"
    echo "  cd $project_name"
    if [[ "$with_direnv" == "true" ]]; then
        echo "  direnv allow  # Allow direnv environment"
    fi
    if [[ "$with_devenv" == "true" ]]; then
        echo "  devenv up     # Start devenv environment"
    fi
    echo "  git add ."
    echo "  git commit -m 'Initial commit'"
    echo ""
    echo "Happy coding! 🚀"
}

# Run main function
main "$@"
