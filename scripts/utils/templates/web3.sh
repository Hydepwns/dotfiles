#!/usr/bin/env bash

# Use simple script initialization (no segfaults!)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../simple-init.sh"

# Web3 template generator for DROO's dotfiles

# Simple utilities (no dependencies)
log_info() { echo -e "${BLUE:-}[INFO]${NC:-} $1"; }
log_success() { echo -e "${GREEN:-}[SUCCESS]${NC:-} $1"; }
log_error() { echo -e "${RED:-}[ERROR]${NC:-} $1" >&2; }
log_warning() { echo -e "${YELLOW:-}[WARNING]${NC:-} $1"; }

# Exit codes
EXIT_SUCCESS=0
EXIT_INVALID_ARGS=1
EXIT_FAILURE=1

# Simple utility functions
file_exists() { test -f "$1"; }
dir_exists() { test -d "$1"; }
command_exists() { command -v "$1" >/dev/null 2>&1; }

# Function to generate web3 project
generate_web3_project() {
    local name="$1"
    local features="$2"

    echo "Creating web3 project: $name"

    # Initialize git
    git init

    # Create basic structure
    mkdir -p src contracts scripts test docs

    # Create README
    cat > README.md << EOF
# $name

Web3 project generated by DROO's dotfiles template.

## Features

- Smart contract development
- Testing framework
- Deployment scripts
- Documentation

## Setup

\`\`\`bash
# Install dependencies
npm install

# For Ethereum development
forge install
forge build
forge test

# For Solana development
anchor build
anchor test
\`\`\`

## Development

\`\`\`bash
# Start local development
npm run dev

# Run tests
npm test

# Deploy contracts
npm run deploy
\`\`\`

## License

MIT
EOF

    # Create package.json
    cat > package.json << EOF
{
  "name": "$name",
  "version": "0.1.0",
  "description": "Web3 project generated by DROO's dotfiles",
  "main": "index.js",
  "scripts": {
    "dev": "echo 'Start development server'",
    "build": "echo 'Build project'",
    "test": "echo 'Run tests'",
    "deploy": "echo 'Deploy contracts'",
    "lint": "echo 'Run linter'",
    "format": "echo 'Format code'"
  },
  "keywords": ["web3", "blockchain", "ethereum", "solana"],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0",
    "prettier": "^3.0.0",
    "eslint": "^8.0.0"
  }
}
EOF

    # Add Ethereum support if requested
    if [[ "$features" == *"ethereum"* ]] || [[ "$features" == *"foundry"* ]]; then
        echo "Adding Ethereum/Foundry support..."
        generate_ethereum_setup "$name"
    fi

    # Add Solana support if requested
    if [[ "$features" == *"solana"* ]] || [[ "$features" == *"anchor"* ]]; then
        echo "Adding Solana/Anchor support..."
        generate_solana_setup "$name"
    fi

    # Create .gitignore
    generate_web3_gitignore
}

# Function to generate Ethereum setup
generate_ethereum_setup() {
    local name="$1"

    # Initialize Foundry
    forge init --no-commit

    # Create foundry.toml
    cat > foundry.toml << EOF
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc_version = "0.8.19"
optimizer = true
optimizer_runs = 200

[profile.default.fuzz]
runs = 1000

[profile.default.invariant]
runs = 1000
depth = 15
fail_on_revert = false
EOF

    # Create sample contract
    cat > src/Counter.sol << EOF
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract Counter {
    uint256 public count;

    event CountIncremented(uint256 newCount);

    function increment() public {
        count++;
        emit CountIncremented(count);
    }

    function decrement() public {
        require(count > 0, "Counter: cannot decrement below zero");
        count--;
        emit CountIncremented(count);
    }
}
EOF

    # Create test
    cat > test/Counter.t.sol << EOF
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;

    function setUp() public {
        counter = new Counter();
    }

    function testIncrement() public {
        counter.increment();
        assertEq(counter.count(), 1);
    }

    function testDecrement() public {
        counter.increment();
        counter.increment();
        counter.decrement();
        assertEq(counter.count(), 1);
    }
}
EOF
}

# Function to generate Solana setup
generate_solana_setup() {
    local name="$1"

    # Create Anchor.toml
    cat > Anchor.toml << EOF
[features]
seeds = false
skip-lint = false

[programs.localnet]
$name = "$name"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"
EOF

    # Create Cargo.toml
    cat > Cargo.toml << EOF
[package]
name = "$name"
version = "0.1.0"
description = "Generated Solana program"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "$name"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []

[dependencies]
anchor-lang = "0.28.0"
EOF

            # Create program
        mkdir -p "programs/$name/src"
        cat > "programs/$name/src/lib.rs" << EOF
use anchor_lang::prelude::*;

declare_id!("$name");

#[program]
pub mod $name {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}
EOF
}

# Function to generate web3 .gitignore
generate_web3_gitignore() {
    cat > .gitignore << EOF
# Dependencies
node_modules/
target/
dist/

# Environment
.env
.env.local
.env.production

# Build outputs
out/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
EOF
}
