#!/usr/bin/env bash
# Rust template generator for DROO's dotfiles

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=../simple-init.sh
source "$SCRIPT_DIR/../simple-init.sh"

# Simple utility functions
file_exists() { test -f "$1"; }
dir_exists() { test -d "$1"; }
command_exists() { command -v "$1" >/dev/null 2>&1; }

# Function to generate Rust project
generate_rust_project() {
    local name="$1"
    local features="$2"

    echo "Creating Rust project: $name"

    # Initialize Cargo project
    cargo init --name "$name"

    # Update Cargo.toml with common dependencies
    generate_cargo_toml "$name" "$features"

    # Create basic structure
    mkdir -p src tests examples

    # Create main.rs
    cat > src/main.rs << EOF
use anyhow::Result;

fn main() -> Result<()> {
    env_logger::init();
    println!("Hello, {}!", env!("CARGO_PKG_NAME"));
    Ok(())
}
EOF

    # Create lib.rs
    cat > src/lib.rs << EOF
use anyhow::Result;

pub fn hello() -> Result<String> {
    Ok("Hello from library!".to_string())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hello() {
        assert!(hello().is_ok());
    }
}
EOF

    # Add additional features if requested
    if [[ "$features" == *"axum"* ]]; then
        echo "Adding Axum web framework..."
        generate_axum_setup "$name"
    fi

    if [[ "$features" == *"serde"* ]]; then
        echo "Adding Serde serialization..."
        # Serde is already included in base dependencies
    fi

    if [[ "$features" == *"tokio"* ]]; then
        echo "Adding Tokio async runtime..."
        # Tokio is already included in base dependencies
    fi

    # Create .gitignore
    generate_rust_gitignore

    # Create README
    generate_rust_readme "$name"
}

# Function to generate Cargo.toml
generate_cargo_toml() {
    local name="$1"
    local features="$2"

    cat > Cargo.toml << EOF
[package]
name = "$name"
version = "0.1.0"
edition = "2021"
authors = ["DROO <drew@axol.io>"]
description = "Rust project generated by DROO's dotfiles"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
thiserror = "1.0"
log = "0.4"
env_logger = "0.10"
EOF

    # Add Axum if requested
    if [[ "$features" == *"axum"* ]]; then
        cat >> Cargo.toml << EOF
axum = "0.7"
tower = "0.4"
tower-http = { version = "0.5", features = ["cors"] }
EOF
    fi

    cat >> Cargo.toml << EOF

[dev-dependencies]
tokio-test = "0.4"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
panic = "abort"
EOF
}

# Function to generate Axum setup
generate_axum_setup() {
    local name="$1"

    # Create web module
    cat > src/web.rs << EOF
use axum::{
    routing::{get, post},
    Router,
    Json,
    http::StatusCode,
};
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;

#[derive(Serialize, Deserialize)]
struct HelloResponse {
    message: String,
}

async fn hello() -> Json<HelloResponse> {
    Json(HelloResponse {
        message: "Hello from Axum!".to_string(),
    })
}

async fn health() -> StatusCode {
    StatusCode::OK
}

pub async fn start_server() {
    let app = Router::new()
        .route("/", get(hello))
        .route("/health", get(health));

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("Server running on http://{}", addr);

    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
EOF

    # Update main.rs to use web server
    cat > src/main.rs << EOF
use anyhow::Result;
use $name::web;

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    println!("Starting {} server...", env!("CARGO_PKG_NAME"));

    web::start_server().await;

    Ok(())
}
EOF

    # Update lib.rs to include web module
    cat > src/lib.rs << EOF
use anyhow::Result;

pub mod web;

pub fn hello() -> Result<String> {
    Ok("Hello from library!".to_string())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hello() {
        assert!(hello().is_ok());
    }
}
EOF
}

# Function to generate Rust .gitignore
generate_rust_gitignore() {
    cat > .gitignore << EOF
/target
Cargo.lock
*.pdb

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log

# Environment
.env
.env.local
EOF
}

# Function to generate Rust README
generate_rust_readme() {
    local name="$1"

    cat > README.md << EOF
# $name

Rust project generated by DROO's dotfiles template.

## Features

- Modern Rust with async/await
- Error handling with anyhow
- Logging with env_logger
- Testing framework
- Web framework (if enabled)

## Setup

\`\`\`bash
# Install Rust (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Build the project
cargo build

# Run the project
cargo run

# Run tests
cargo test

# Check code
cargo check
cargo clippy
cargo fmt
\`\`\`

## Development

\`\`\`bash
# Start development server
cargo run

# Run tests
cargo test

# Format code
cargo fmt

# Lint code
cargo clippy
\`\`\`

## License

MIT
EOF
}
