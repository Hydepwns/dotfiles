#!/usr/bin/env bash

# Dotfiles CLI - User-friendly interface for dotfiles management
# Transforms complex script paths into simple commands

# Source shared utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
UTILS_DIR="$SCRIPT_DIR/scripts/utils"
[ -f "$UTILS_DIR/common.sh" ] && source "$UTILS_DIR/common.sh"

setup_error_handling

# CLI Configuration
CLI_VERSION="1.0.0"
DEFAULT_COMMAND="help"

# Command registry - maps commands to their script paths
declare -A COMMANDS=(
    # Setup commands
    ["setup"]="scripts/setup/bootstrap.sh"
    ["setup:nixos"]="scripts/setup/nixos-quick-fix.sh"
    ["setup:cursor"]="scripts/setup/setup-cursor-simple.sh"
    ["setup:github"]="scripts/setup/setup-github-token.sh"
    ["quickfix"]="scripts/setup/nixos-quick-fix.sh"
    
    # Development commands  
    ["new"]="scripts/utils/template-manager.sh"
    ["dev"]="scripts/utils/dev-workflow.sh"
    
    # Maintenance commands
    ["test"]="scripts/utils/test-suite.sh"
    ["verify"]="scripts/utils/verify-setup.sh"
    ["health"]="scripts/utils/health-check.sh"
    ["sync"]="scripts/utils/sync.sh"
    ["backup"]="scripts/utils/backup.sh"
    ["clean"]="scripts/utils/clean.sh"
    
    # Performance commands
    ["bench"]="scripts/utils/lazy-loading-benchmark.sh"
    ["perf"]="scripts/utils/performance-test.sh"
    ["monitor"]="scripts/utils/performance-monitor.sh"
    
    # Quality commands
    ["quality"]="scripts/ci/quality-check.sh"
    ["lint"]="scripts/ci/quality-check.sh check"
    
    # Cache commands
    ["cache"]="scripts/utils/cache.sh"
    ["cache:stats"]="scripts/utils/cache.sh stats"
    ["cache:clear"]="scripts/utils/cache.sh clear"
    ["cache:warmup"]="scripts/utils/cache.sh warmup"
    
    # Utility commands
    ["conflicts"]="scripts/utils/check-conflicts.sh"
    ["templates"]="scripts/utils/template-manager.sh"
    ["config"]="scripts/utils/config-manager.sh"
    
    # Advanced features
    ["test:run"]="tests/framework/test-runner.sh run"
    ["test:coverage"]="tests/framework/test-runner.sh coverage"
    ["docs"]="scripts/docs/generate-docs.sh all"
    ["docs:api"]="scripts/docs/generate-docs.sh api"
    ["plugin"]="scripts/plugins/plugin-manager.sh"
    ["plugin:list"]="scripts/plugins/plugin-manager.sh list"
    ["plugin:create"]="scripts/plugins/plugin-manager.sh create"
    ["monitor"]="scripts/monitoring/observability.sh"
    ["monitor:start"]="scripts/monitoring/observability.sh start"
    ["monitor:dashboard"]="scripts/monitoring/observability.sh dashboard"
    ["profile"]="scripts/utils/profiler.sh"
    
    # Dashboard commands
    ["dashboard"]="scripts/utils/dashboard-server.sh open"
    ["dashboard:start"]="scripts/utils/dashboard-server.sh start"
    ["dashboard:stop"]="scripts/utils/dashboard-server.sh stop"
    ["dashboard:status"]="scripts/utils/dashboard-server.sh status"
    ["dashboard:logs"]="scripts/utils/dashboard-server.sh logs"
)

# Command descriptions for help
declare -A DESCRIPTIONS=(
    ["setup"]="Bootstrap dotfiles on a new system"
    ["setup:nixos"]="NixOS-specific setup and configuration"
    ["setup:cursor"]="Setup Cursor IDE configuration"
    ["setup:github"]="Configure GitHub token and authentication"
    ["setup:ci"]="Setup CI/CD configuration"
    ["quickfix"]="Quick fix for common NixOS issues"
    
    ["new"]="Generate new project from templates"
    ["dev"]="Development workflow tools"
    
    ["test"]="Run comprehensive test suite"
    ["verify"]="Verify dotfiles setup and configuration"
    ["health"]="System health check and diagnostics"
    ["update"]="Update tool versions and dependencies"
    ["sync"]="Sync dotfiles with remote repository"
    ["backup"]="Create backup of important configurations"
    ["clean"]="Clean up temporary files and caches"
    
    ["bench"]="Run performance benchmarks"
    ["perf"]="Performance testing and analysis"
    ["monitor"]="Real-time performance monitoring"
    
    ["quality"]="Code quality analysis with ShellCheck"
    ["lint"]="Run linting and static analysis"
    
    ["cache"]="Cache management operations"
    ["cache:stats"]="Show cache statistics"  
    ["cache:clear"]="Clear all cache entries"
    ["cache:warmup"]="Pre-populate cache with common operations"
    
    ["conflicts"]="Check for configuration conflicts"
    ["templates"]="Manage project templates"
    ["config"]="Configuration management utilities"
    
    # Advanced features descriptions
    ["test:run"]="Run comprehensive test suite with coverage"
    ["test:coverage"]="Show detailed test coverage analysis"
    ["docs"]="Generate complete documentation"
    ["docs:api"]="Generate API reference documentation"
    ["plugin"]="Plugin management system"
    ["plugin:list"]="List available plugins"
    ["plugin:create"]="Create new plugin template"
    ["monitor"]="System monitoring and observability"
    ["monitor:start"]="Start continuous monitoring"
    ["monitor:dashboard"]="Open monitoring dashboard"
    ["profile"]="Performance profiling tools"
    
    # Dashboard descriptions
    ["dashboard"]="Open web-based dashboard interface"
    ["dashboard:start"]="Start the dashboard web server"
    ["dashboard:stop"]="Stop the dashboard web server"
    ["dashboard:status"]="Check dashboard server status"
    ["dashboard:logs"]="View dashboard server logs"
)

# Command categories for organized help
declare -A CATEGORIES=(
    ["Setup"]="setup setup:nixos setup:cursor setup:github setup:ci quickfix"
    ["Development"]="new dev"
    ["Testing & Quality"]="test verify health quality lint"
    ["Performance"]="bench perf monitor profile"
    ["Testing & Documentation"]="test test:run test:coverage docs docs:api" 
    ["Plugin System"]="plugin plugin:list plugin:create"
    ["Monitoring & Observability"]="monitor monitor:start monitor:dashboard dashboard dashboard:start dashboard:stop dashboard:status health"
    ["Maintenance"]="update sync backup clean cache cache:stats cache:clear cache:warmup"
    ["Utilities"]="conflicts templates config"
)

# Color scheme for CLI output
if [[ -t 1 ]]; then  # Only use colors if outputting to terminal
    CLI_BOLD='\033[1m'
    CLI_DIM='\033[2m'
    CLI_BLUE='\033[34m'
    CLI_GREEN='\033[32m'
    CLI_YELLOW='\033[33m'
    CLI_RED='\033[31m'
    CLI_CYAN='\033[36m'
    CLI_RESET='\033[0m'
else
    CLI_BOLD='' CLI_DIM='' CLI_BLUE='' CLI_GREEN='' CLI_YELLOW='' CLI_RED='' CLI_CYAN='' CLI_RESET=''
fi

# Print CLI header
print_header() {
    echo -e "${CLI_BOLD}${CLI_BLUE}üè† Dotfiles CLI v${CLI_VERSION}${CLI_RESET}"
    echo -e "${CLI_DIM}Streamlined dotfiles management${CLI_RESET}"
    echo ""
}

# Print command help
print_help() {
    print_header
    
    echo -e "${CLI_BOLD}Usage:${CLI_RESET}"
    echo "  dotfiles <command> [arguments]"
    echo ""
    
    echo -e "${CLI_BOLD}Available Commands:${CLI_RESET}"
    echo ""
    
    for category in "${!CATEGORIES[@]}"; do
        echo -e "${CLI_BOLD}${CLI_YELLOW}${category}:${CLI_RESET}"
        
        for cmd in ${CATEGORIES[$category]}; do
            local desc="${DESCRIPTIONS[$cmd]:-No description available}"
            printf "  ${CLI_GREEN}%-15s${CLI_RESET} %s\n" "$cmd" "$desc"
        done
        echo ""
    done
    
    echo -e "${CLI_BOLD}Examples:${CLI_RESET}"
    echo "  dotfiles setup                 # Bootstrap dotfiles"
    echo "  dotfiles new web3 my-project   # Create new Web3 project"
    echo "  dotfiles test                  # Run test suite"
    echo "  dotfiles quality               # Check code quality"
    echo "  dotfiles cache:warmup          # Pre-populate cache"
    echo ""
    
    echo -e "${CLI_BOLD}Global Options:${CLI_RESET}"
    echo "  --help, -h                     # Show help for any command"
    echo "  --version, -v                  # Show CLI version"
    echo "  --verbose                      # Enable verbose output"
    echo "  --dry-run                      # Show what would be executed"
    echo ""
}

# Validate command exists
validate_command() {
    local cmd="$1"
    
    if [[ -z "${COMMANDS[$cmd]}" ]]; then
        echo -e "${CLI_RED}Error:${CLI_RESET} Unknown command '${CLI_YELLOW}$cmd${CLI_RESET}'"
        echo ""
        echo "Run '${CLI_CYAN}dotfiles help${CLI_RESET}' to see available commands."
        echo ""
        
        # Suggest similar commands
        echo -e "${CLI_DIM}Did you mean?${CLI_RESET}"
        for available_cmd in "${!COMMANDS[@]}"; do
            if [[ "$available_cmd" =~ $cmd ]]; then
                echo "  ${CLI_GREEN}$available_cmd${CLI_RESET}"
            fi
        done
        
        return $EXIT_INVALID_ARGS
    fi
    
    return $EXIT_SUCCESS
}

# Execute command with proper error handling
execute_command() {
    local cmd="$1"
    shift
    local args=("$@")
    
    local script_path="${COMMANDS[$cmd]}"
    local full_path="$SCRIPT_DIR/$script_path"
    
    # Check if script exists
    if [[ ! -f "$full_path" ]]; then
        echo -e "${CLI_RED}Error:${CLI_RESET} Script not found: $full_path"
        return $EXIT_FILE_NOT_FOUND
    fi
    
    # Check if script is executable
    if [[ ! -x "$full_path" ]]; then
        echo -e "${CLI_YELLOW}Warning:${CLI_RESET} Making script executable: $script_path"
        chmod +x "$full_path"
    fi
    
    # Show what we're executing (if verbose or dry-run)
    if [[ "$VERBOSE" == "true" ]] || [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${CLI_DIM}Executing: $script_path ${args[*]}${CLI_RESET}"
        
        if [[ "$DRY_RUN" == "true" ]]; then
            return $EXIT_SUCCESS
        fi
    fi
    
    # Execute the script
    cd "$SCRIPT_DIR" || exit $EXIT_FAILURE
    bash "$full_path" "${args[@]}"
}

# Handle special cases and command aliases
handle_special_commands() {
    local cmd="$1"
    
    case "$cmd" in
        "help"|"--help"|"-h"|"")
            print_help
            return 0
            ;;
        "version"|"--version"|"-v")
            echo "Dotfiles CLI v${CLI_VERSION}"
            return 0
            ;;
        "list"|"ls")
            echo -e "${CLI_BOLD}Available commands:${CLI_RESET}"
            for cmd in "${!COMMANDS[@]}"; do
                echo "  ${CLI_GREEN}$cmd${CLI_RESET}"
            done | sort
            return 0
            ;;
        "status")
            execute_command "verify" "$@"
            return $?
            ;;
        "install")
            execute_command "setup" "$@"
            return $?
            ;;
        *)
            return 1  # Not a special command
            ;;
    esac
}

# Parse global options
parse_options() {
    VERBOSE=false
    DRY_RUN=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --verbose)
                VERBOSE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                VERBOSE=true  # Implied by dry-run
                shift
                ;;
            --help|-h)
                print_help
                exit $EXIT_SUCCESS
                ;;
            --version|-v)
                echo "Dotfiles CLI v${CLI_VERSION}"
                exit $EXIT_SUCCESS
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo -e "${CLI_RED}Error:${CLI_RESET} Unknown option: $1"
                exit $EXIT_INVALID_ARGS
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Return remaining arguments
    echo "$@"
}

# Tab completion support (for advanced users)
generate_completions() {
    local current_word="${COMP_WORDS[COMP_CWORD]}"
    local commands=($(compgen -W "${!COMMANDS[*]}" -- "$current_word"))
    COMPREPLY=("${commands[@]}")
}

# Enable bash completion if being sourced
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    complete -F generate_completions dotfiles
fi

# Main CLI function
main() {
    # Parse global options
    local remaining_args
    remaining_args=$(parse_options "$@")
    eval "set -- $remaining_args"
    
    local command="${1:-$DEFAULT_COMMAND}"
    shift || true
    
    # Handle special commands first
    if handle_special_commands "$command" "$@"; then
        return $?
    fi
    
    # Validate regular command
    if ! validate_command "$command"; then
        return $EXIT_INVALID_ARGS
    fi
    
    # Execute the command
    execute_command "$command" "$@"
    local exit_code=$?
    
    # Provide feedback on command completion
    if [[ $exit_code -eq 0 ]]; then
        if [[ "$VERBOSE" == "true" ]]; then
            echo -e "${CLI_GREEN}‚úì${CLI_RESET} Command '${CLI_CYAN}$command${CLI_RESET}' completed successfully"
        fi
    else
        echo -e "${CLI_RED}‚úó${CLI_RESET} Command '${CLI_CYAN}$command${CLI_RESET}' failed with exit code $exit_code"
    fi
    
    return $exit_code
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi